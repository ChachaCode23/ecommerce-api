spring.application.name=ecommerce-api
# Nombre interno de la app Spring Boot

server.port=8080
# Puerto donde corre la API. Si levanto el backend, responde en http://localhost:8080

# ===================== \u2705 API BASE URL (FASE 3.2) =====================
# URL base para los ApiClients que consumen endpoints REST
# Ahora todo corre en el mismo puerto 8080
api.base.url=http://localhost:8080
# Esta URL la usan los *ApiClient* (ProductoApiClient, PedidoApiClient, etc.)
# para armar las rutas: api.base.url + /api/

# ===================== ACTUATOR =====================
management.endpoints.web.exposure.include=health,info,mappings
# Con esto expongo solo estos endpoints de Actuator por HTTP:
# - /actuator/health  -> estado de la app
# - /actuator/info    -> info básica de la app
# - /actuator/mappings -> lista de endpoints registrados

# ===================== SPRINGDOC / SWAGGER =====================
springdoc.api-docs.enabled=true
# Activa la generación del JSON OpenAPI 

springdoc.swagger-ui.enabled=true
# Activa la interfaz gráfica de Swagger UI

springdoc.api-docs.path=/v3/api-docs
# Ruta donde se sirve el JSON de la documentación OpenAPI

springdoc.swagger-ui.path=/swagger-ui.html
# Ruta de la UI de Swagger para probar la API desde el navegador

springdoc.packages-to-scan=com.urbancollection.ecommerce.api.web
# Paquete donde SpringDoc va a buscar los controllers para documentarlos

springdoc.paths-to-match=/api/**,/ping,/db/**
# Solo documenta estos paths:
# - /api/** -> todos los endpoints REST
# - /ping   -> endpoint de salud simple
# - /db/**  -> cualquier endpoint que empiece con /db/

# ===================== BASE DE DATOS =====================
spring.datasource.url=jdbc:sqlserver://localhost:1433;databaseName=EcommerceDB;encrypt=false;trustServerCertificate=true
# URL de conexión a SQL Server:
# - Host: localhost
# - Puerto: 1433 (por defecto de SQL Server)
# - DB: EcommerceDB
# - encrypt=false / trustServerCertificate=true para evitar problemas de SSL en local

spring.datasource.driver-class-name=com.microsoft.sqlserver.jdbc.SQLServerDriver
# Driver JDBC específico para SQL Server

spring.datasource.username=sa
# Usuario de la base de datos (por ahora el clásico 'sa' en local)

spring.datasource.password=Josejose23@
# Contraseña del usuario 'sa' 

# \u2705 NUEVO AJUSTE: Aumentar el tiempo de espera por si SQL Server tarda en responder
spring.datasource.hikari.connection-timeout=60000 
# Tiempo máximo de espera (en ms) para conseguir una conexión del pool Hikari
# 60000 ms = 60 segundos

# ===================== JPA / HIBERNATE =====================
spring.jpa.hibernate.ddl-auto=update
# Hibernate actualiza el esquema de la base de datos según las entidades
# (útil en desarrollo, en producción normalmente se usa 'validate' o se manejan scripts aparte)

spring.jpa.show-sql=true
# Muestra las sentencias SQL que genera Hibernate en la consola/logs

spring.jpa.properties.hibernate.format_sql=true
# Formatea el SQL para que se vea más legible en la consola
